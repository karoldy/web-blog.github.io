# 编程基础知识

### 简述Session 与 Cookie的区别 ？

```
Session 与 Cookie的区别：

1. 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。


2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
```

### 表单中 Get与Post提交方法的区别?

```
一、GET和POST的定义
GET和POST是两种最基本的HTTP请求方法。HTTP是超文本传输协议，用于在Web浏览器和Web服务器之间传输数据。HTTP请求方法定义了Web浏览器如何向Web服务器发送请求。GET和POST是最常用的HTTP请求方法之一。
GET方法用于从Web服务器请求数据。在使用GET方法时，浏览器向Web服务器发送一个请求，Web服务器将响应数据发送回浏览器。GET方法是无状态的，也就是说每个请求都是独立的，没有前后关系。GET方法通常用于请求静态数据，如HTML页面、图片和CSS文件等。
POST方法用于向Web服务器提交数据。在使用POST方法时，浏览器将数据打包并发送到Web服务器。Web服务器收到数据后，可以根据数据执行相应的操作，并向浏览器发送响应。POST方法是有状态的，也就是说请求和响应之间存在关系，请求和响应之间的数据可以互相传递。POST方法通常用于向Web服务器提交表单数据和上传文件等操作。


二、GET和POST的区别
1.数据传输方式不同
GET方法的数据传输是通过URL传递的，而POST方法的数据传输是通过HTTP请求体传递的。在使用GET方法时，浏览器将请求的参数附加到URL的末尾，以“?”号开始，并用“&”符号将多个参数连接在一起。例如，以下是使用GET方法请求的示例：
http://example.com/page?name=value&age=value
在使用POST方法时，浏览器将请求的数据打包并放置在HTTP请求体中。请求头中会包含请求体的大小等信息。以下是使用POST方法请求的示例：
POST /page HTTP/1.1 Host: example.com Content-Type: application/x-www-form-urlencoded Content-Length: 20
name=value&age=value

2.数据大小限制不同
GET方法将数据附加到URL中，因此数据大小有限制。在URL中，只能传递ASCII字符，并且URL的长度有限制。不同的浏览器和Web服务器对URL长度的限制不同，但通常在2KB到8KB之间。因此，使用GET方法传输大量数据可能会导致URL过长，从而影响请求的性能。
POST方法将数据放在HTTP请求体中，因此数据大小不受限制。但是，Web服务器和Web应用程序可能会对POST请求的大小进行限制。这是为了避免网络拥塞和服务器过载等问题。通常，Web服务器和Web应用程序对POST请求的大小限制在1MB到2MB之间。


3.安全性不同
GET方法的参数是通过URL传递的，因此可以很容易地在浏览器地址栏中看到。如果参数包含敏感信息，例如用户名和密码等，这将是一个安全风险。因此，GET方法不适合传递敏感数据。

POST方法将数据放在HTTP请求体中，因此相对于GET方法更加安全。因为POST方法的请求体不会在浏览器地址栏中显示，所以敏感信息不会暴露在URL中。但是，POST方法的请求体可能会被截获并读取，所以如果数据是敏感的，还需要采取其他安全措施。

4.缓存机制不同
GET方法具有缓存机制。如果浏览器请求的资源已经在本地缓存中存在，浏览器将使用缓存而不是向服务器发送请求。这可以提高Web应用程序的性能。但是，如果应用程序的数据频繁变化，使用GET方法可能会导致浏览器缓存过期，从而影响性能。
POST方法没有缓存机制。每次使用POST方法发送请求时，浏览器都会向Web服务器发送请求，Web服务器也会重新处理请求。因此，POST方法的性能相对于GET方法较低。

5.幂等性不同
在计算机科学中，幂等性是指对同一操作执行多次所产生的影响是相同的。在HTTP协议中，GET方法是幂等的，也就是说对同一URL执行多次GET请求，服务器的响应是相同的。因为GET方法只用于获取资源，不对服务器端的资源做任何改变。
而POST方法不是幂等的，也就是说对同一URL执行多次POST请求，服务器的响应可能会不同。因为POST方法会对服务器端的资源进行改变，如果多次执行相同的POST请求，可能会导致服务器的状态发生变化。
```

### 简述什么是软件架构的MVC？

```
MVC由Model（模型）, View（视图）和Controller（控制器）组成，PHP MVC可以更高效地管理好3个不同层的PHP代码。
Model：数据信息存取层。
View：view层负责将应用的数据以特定的方式展现在界面上。
Controller：通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。
```

### 网站设计中应注意的原则？

```
网站制作需要遵循的六大原则：
随着互联网的迅速发展，网站已经成为企业和个人展示自己的重要方式之一。然而，一个成功的网站并不是简单地凭借一些图文信息就能完成的，它需要遵循一些设计原则，以提供良好的用户体验和吸引用户的注意力。本文将介绍网站制作需要遵循的六大原则。

一、可用性
可用性是网站设计中最重要的原则之一。一个可用性良好的网站能够提供简单、直观的操作界面，帮助用户快速找到他们想要的信息。要实现良好的可用性，需要考虑以下几个方面：
1. 易学性：网站应该具有简单易懂的操作流程和一致的界面设计，以便用户能够快速上手并且方便使用。
2. 可预测性：网站的操作应该符合用户的预期。例如，搜索功能应该放在易于找到的位置，导航栏的布局应该符合用户常见的习惯。
3. 反馈性：当用户完成一个操作时，网站应该给予及时的反馈，让用户知道他们的操作是否成功。
4. 易纠错性：当用户犯错时，网站应该提供清晰明确的错误提示，帮助用户纠正错误。
二、可读性
可读性是网站制作中不可忽视的原则。一个可读性好的网站能够提供清晰、易于阅读的文本内容，让用户可以轻松地吸收信息。要实现良好的可读性，需要考虑以下几个方面：
1. 字体选择：网站的字体应该具有良好的可读性，即清晰、易于辨认，并且不易疲劳。常用的字体包括Arial、Helvetica等。
2. 字号和行间距：合适的字号和行间距能够提高文本的可读性。字号过小或行间距过小会导致用户眼睛疲劳，影响阅读体验。
3. 色彩对比度：网站的文字和背景之间应该有良好的对比度，以确保文字清晰可见。
4. 文本排版：网站的排版应该清晰有序，段落之间应该有明显的分隔，以便用户可以轻松地阅读内容。
三、导航性
导航性是网站设计中至关重要的原则之一。一个良好的导航系统能够帮助用户快速找到他们想要的内容，提高用户体验。要实现良好的导航性，需要考虑以下几个方面：
1. 导航栏布局：导航栏应该位于页面的顶部或左侧，以便用户可以轻松找到。导航栏的布局应该简单明了，包含不超过七个的主导航链接，避免过于复杂。
2. 面包屑导航：面包屑导航能够告诉用户他们当前所在的位置，并且提供返回上一级或直接回到首页的链接。
3. 搜索功能：网站应该提供搜索功能，让用户可以通过关键词快速找到他们想要的内容。
4. 内部链接：在网页的内容中，应该合理地添加内部链接，以便用户能够快速跳转到相关内容。
四、响应式设计
随着移动互联网的快速发展，越来越多的用户使用手机和平板电脑访问网站。因此，网站制作需要考虑响应式设计，以确保用户在不同设备上都能够正常访问和浏览网站。要实现良好的响应式设计，需要考虑以下几个方面：
1. 弹性布局：使用弹性布局可以根据不同的设备和屏幕尺寸自动调整页面的布局和大小。
2. 自适应图片：在网站中使用自适应的图片，可以根据设备的屏幕尺寸自动调整图片的大小。
3. 媒体查询：使用媒体查询可以根据设备的不同设置不同的CSS样式，以适应不同的屏幕大小和分辨率。
五、页面加载速度
页面加载速度是网站制作中一个重要的考虑因素，它直接影响用户的体验和满意度。一个加载速度快的网站能够提高用户留存率和转化率。要提高页面加载速度，可以考虑以下几个方面：
1. 优化图片：使用合适的图片格式，压缩图片大小，并使用合适的缓存策略，以减少图片加载时间。
2. 压缩代码：去掉无用的代码，并进行压缩和合并，以减少网页的大小和加载时间。
3. 合理使用缓存：合理设置缓存策略，以减少重复加载的时间和带宽消耗。
六、安全性
安全性是网站制作中一个非常重要的原则，特别是对于涉及用户个人信息和交易的网站。要保证网站的安全性，可以考虑以下几个方面：
1. 使用安全证书：为网站添加SSL证书，使用HTTPS安全协议，以保护用户的数据传输安全。
2. 定期更新程序和插件：保持网站的程序和插件的更新，修复已知的安全漏洞，提高网站的安全性。
3. 密码加密存储：用户的密码应该进行加密存储，以防止泄露和破解。
总结：
网站制作需要遵循的六大原则包括可用性、可读性、导航性、响应式设计、页面加载速度和安全性。通过遵循这些原则，可以有效提高网站的用户体验，吸引用户的关注，并提高网站的转化率和用户留存率。同时，要根据不同的业务需求和目标用户的特点，合理选择和调整这些原则，以实现的设计效果。
```

### 简述doGet()方法和doPost()方法有什么区别？

```
doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。

doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。
```

### 解释什么是Web应用程序？

```
定义
Web应用程序是一种利用网络浏览器和网络技术在互联网上执行任务的计算机程序。

总览
数以百万计的企业将互联网作为一个具有成本效益的通信渠道。它使他们能够与目标市场交换信息，并进行快速，安全的交易。但是，只有在企业能够捕获和存储所有必要数据，并有办法处理这些信息并将结果呈现给用户时，才有可能有效地参与。

Web应用程序使用服务器端脚本（PHP和ASP）的组合来处理信息的存储和检索，并使用客户端脚本（JavaScript和HTML）将信息呈现给用户。这允许用户可以使用在线表单，内容管理系统，购物车等与公司互动。此外，这些应用程序还允许员工创建文档、共享信息、协作项目以及在共同的文档上工作，而不受地点或设备的限制。

Web应用程序如何工作
Web应用程序通常用浏览器支持的语言（例如JavaScript和HTML）编写，因为这些语言依赖浏览器来呈现程序可执行文件。一些应用程序是动态的，需要服务器端处理。其他应用程序则完全是静态的，无需在服务器上进行任何处理。

Web应用程序需要一个Web服务器来管理来自客户端的请求，一个应用服务器来执行所请求的任务，有时还需要一个数据库来存储信息。应用服务器技术的范围从http://ASP.NET，ASP和ColdFusion到PHP和JSP。

以下是一个典型的Web应用流程：

1. 用户通过网络浏览器或应用程序的用户界面，通过互联网触发对网络服务器的请求
2. Web服务器将此请求转发到适当的Web服务器
3. Web服务器执行请求的任务（例如查询数据库或处理数据），然后生成请求数据的结果
4. Web服务器将处理后的数据或请求的信息或已处理数据的结果一起发送到Web服务器
5. Web服务器用所请求的信息响应客户端，该信息随后出现在用户的显示屏上

Web应用程序示例
Web应用程序包括在线表单，购物车，文字处理器，电子表格，视频和照片编辑，文件转换，文件扫描以及电子邮件程序，例如Gmail，Yahoo和AOL。流行的应用程序包括Google Apps和Microsoft 365。

Google Apps 在办公领域的应用程序有Gmail，Google Docs，Google Forms，Google Slides，在线存储等。其他功能包括在线共享文档和日历。这可以让所有团队成员同时访问同一版本的文档。

Web应用程序的好处
只要浏览器兼容，Web应用程序就可以在多个平台上运行，不受操作系统或设备的影响。
所有用户都访问同一版本，消除了所有兼容性问题
它们并未安装在硬盘驱动器上，因此消除了空间限制
它们减少了基于订阅的Web应用程序（即SaaS）中的软件盗版。
它们降低了企业和最终用户的成本，因为企业所需的支持和维护更少，对最终用户的计算机的要求也更低
结论
公司和个人之间不断增加的Internet使用率已经影响了企业的运营方式。随着公司从传统模式向云端模式和网格的模式转变，这导致了Web应用程序的广泛使用。Web应用程序使企业能够简化其运营，提高效率并降低成本。

这些在线应用程序，例如电子邮件客户端，文字处理器，电子表格和其他程序，提供与桌面版本相同的功能。然而，它们还有一个额外的优势，那就是可以跨多个平台工作，具有更广泛的影响力，并且可以从任何地方轻松访问。
```

### 简述什么是URL编码和URL解码？

```
URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。
```

### while循环和do循环有什么不同？

```
while结构在循环的开始判断下一个迭代是否应该继续。

do/while结构在循环的结尾来判断是否将继续下一轮迭代。do结构至少会执行一次循环体
```

### 简述类型向下转换是什么?

```
向下转换是指由一个通用类型转换成一个具体的类型，在继承结构上向下进行
```

### 请叙述静态类型有什么特点?

```
静态变量是和类绑定到一起的，而不是类的实例对象。每一个实例对象都共享同样一份静态变量。也就是说，一个类的静态变量只有一份，不管它有多少个对象。类变量或者说静态变量是通过static这个关键字来声明的。类变量通常被用作常量。静态变量通常通过类名字来进行访问。当程序运行的时候这个变量就会创建直到程序结束后才会被销毁。类变量的作用域和实例变量是一样的。它的初始值和成员变量也是一样的，当变量没被初始化的时候根据它的数据类型，会有一个默认值。类似的，静态方法是属于类的方法，而不是类对象，它的调用并不作用于类对象，也不需要创建任何的类实例。静态方法本身就是final的，因为重写只会发生在类实例上，静态方法是和类绑定在一起的，不是对象。父类的静态方法会被子类的静态方法屏蔽，只要原来方法没有声明为final。非静态方法不能重写静态方法，也就是说，你不能在子类中把一个静态方法改成实例方法。
非静态变量在每一个对象实例上都有单独的一份值。
```

### &操作符和&&操作符有什么区别?

```
当一个&表达式在求值的时候，两个操作数都会被求值，&&更像是一个操作符的快捷方式。当一个&&表达式求值的时候，先计算第一个操作数，如果它返回true才会计算第二个操作数。如果第一个操作数取值为fale,第二个操作数就不会被求值。
```

### 如何理解程序开发中变量？

```
变量是一块命名的内存区域，以便程序进行访问。变量用来存储数据，随着程序的执行，存储的数据也可能跟着改变
```

### 请解释数值提升是什么?

```
数值提升是指数据从一个较小的数据类型转换成为一个更大的数据类型，以便进行整型或者浮点型运算。在数值提升的过程中，byte,char,short值会被转化成int类型。需要的时候int类型也可能被提升成long。long和float则有可能会被转换成double类型。
```

### 如何原地交换两个变量的值？

```
先把两个值相加赋值给第一个变量，然后用得到的结果减去第二个变量，赋值给第二个变量。再用第一个变量减去第二个变量，同时赋值给第一个变量。代码如下：
int a=5,b=10;a=a+b; b=a-b; a=a-b;
```

### 简述Forward和Redirect的区别?

```
forward是转发，浏览器跳转后不显示新的地址。
redirect是重定向，浏览器跳转后显示新的地址。
对比之下forward更加高效，并且它有助于隐藏实际地址，但是有些情况则必须使用redirect，否则会报异常
```

### 内存溢出和内存泄漏有什么区别？何时会产生内存泄漏？内存优化有哪些方法？

```
内存溢出通俗理解就是软件（应用）运行需要的内存，超出了它可用的最大内存。
内存泄漏就是我们对某一内存空间的使用，使用完成后没有释放。
内存优化：Android中容易内存溢出的部分，就是图片的加载，我们可以使用图片的压缩加上使用LruCache缓存的目的来控制图片所能够使用的内存。
还有对于比较耗资源的对象及时的关闭，例如Database Conn , 各种传感器 ， Service 等等。
```

### 嵌入式操作系统内存管理有哪几种， 各有何特性?

```
页式，段式，段页，用到了MMU,虚拟空间等技术
```

### 深拷贝和浅拷贝的理解 ？

```
如果对象有个指针型成员变量指向内存中的某个资源，那么如何复制这个对象呢？你会只是复制指针的值传给副本的新对象吗？指针只是存储内存中资源地址的占位符。在复制操作中，如果只是将指针复制给新对象，那么底层的资源实际上仍然由两个实例在共享。

浅复制：两个实例的指针仍指向内存中的同一资源，只复制指针值而不是实际资源；
深复制：不仅复制指针值，还复制指向指针所指向的资源
```

### 如何理解MVC设计模式

```
MVC是一种架构模式，M表示MOdel，V表示视图View，C表示控制器Controller：

Model负责存储、定义、操作数据；
View用来展示书给用户，和用户进行操作交互；

Controller是Model和View的协调者，Controller把Model中的数据拿过来给View用。Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，MOdel也要与Controller进行通信，这个时候就要用Notification和KVO，这个方式就像一个广播一样，MOdel发信号，Controller设置监听接受信号，当有数据更新时就发信号给Controller，Model和View不能直接进行通信，这样会违背MVC设计模式。
```

### 简述同步和异步的区别？

```
同步是阻塞模式，异步是非阻塞模式。
同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；
异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率
```

### 简述WebService的概念 ？

```
WebService服务可以描述为可以在web上部署并可以被任何应用程序或其他服务调用的功能。所谓服务就是系统提供一组接口，并通过接口使用系统提供的功能，WebService服务可以提供任何企业到客户，企业到企业，点对点或部门对部门通讯所需的服务，比如一个公司可以通过网络连接到另一个公司的服务，从而直接传递订购单。
```

### 概述O/R Mapping 的原理

```
ORM，即Object-RelationlMapping，它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了。下面是在网上转载的一段文章中对它的描述：

　　让我们从O/R开始。字母O起源于"对象"(Object),而R则来自于"关系"(Relational)。几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。

当你开发一个应用程序的时候(不使用O/RMapping),你可能会写不少数据访问层的代码，用来从数据库保存，删除，读取对象信息，等等。你在DAL中写了很多的方法来读取对象数据，改变状态对象等等任务。而这些代码写起来总是重复的。

　　如果打开你最近的程序，看看DAL代码，你肯定会看到很多近似的通用的模式。我们以保存对象的方法为例，你传入一个对象，为SqlCommand对象添加SqlParameter，把所有属性和对象对应，设置SqlCommand的CommandText属性为存储过程，然后运行SqlCommand。对于每个对象都要重复的写这些代码。

　　除此之外，还有更好的办法吗？有，引入一个O/R Mapping。实质上，一个O/R Mapping会为你生成DAL。与其自己写DAL代码，不如用O/RMapping。你用O/R Mapping保存，删除，读取对象，O/R Mapping负责生成SQL，你只需要关心对象就好。
```

### 值类型和引用类型的区别？

```
基于值类型的变量直接包含值。将一个值类型变量赋给另一个值类型变量时，将复制包含的值。这与引用类型变量的赋值不同，引用类型变量的赋值只复制对对象的引用，而不复制对象本身。

　　所有的值类型均隐式派生自 System.ValueType。与引用类型不同，从值类型不可能派生出新的类型。但与引用类型相同的是，结构也可以实现接口。

　　与引用类型不同，值类型不可能包含 null 值。然而，可空类型功能允许将null 赋给值类型。 每种值类型均有一个隐式的默认构造函数来初始化该类型的默认值。

值类型主要由两类组成：结构、枚举； 结构分为以下几类：Numeric（数值）类型、整型、浮点型、decimal、bool、用户定义的结构。

引用类型的变量又称为对象，可存储对实际数据的引用。声明引用类型的关键字：class、interface、delegate、内置引用类型： object、string
```

### Override, Overload,的区别？

```
Override是重写的意思，它表示重写基类的方法，而且方法的名称，返回类型，参数类型，参数个数要与基类相同。

Overload是重载是意思，它也表示重写基类的方法，但是只要方法名相同，别的可以不同。
```

### Heap与stack的差别？

```
Heap是堆，空间是由手动操作分配和释放的，它的存储区很大的自由存储区。

Stack是栈，是由是操作系统自动分配和释放的，栈上的空间是有限的。程序在编译期间变量和函数分配内存都是在栈上进行的，且在运行时函数调用时的参数的传递也是在栈上进行的
```

### 简述怎么实现跨域请求 ？

```
1、jsonp
最常见的一种跨域方式，其背后原理就是利用了 script 标签不受同源策略的限制，在页面中动态插入了 script，script 标签的 src 属性就是后端 api 接口的地址，并且以 get 的方式将前端回调处理函数名称告诉后端，后端在响应请求时会将回调返还，并且将数据以参数的形式传递回去。jsonp 只能发送 get 请求。

2、CORS
Cross-Origin Resource Sharing（跨域资源共享）是一种允许当前域（origin）的资源（比如html/js/web service）被其他域（origin）的脚本请求访问的机制。
当使用 XMLHttpRequest 发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头 origin，后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin，值就是发起请求的源地址(http://127.0.0.1:8888)，浏览器得到响应会进行判断 Access-Control-Allow-Origin 的值是否和当前的地址相同，只有匹配成功后才进行响应处理。
现代浏览器中和移动端都支持 CORS（除了opera mini），IE 下需要8+
3、服务器跨域
在前后端分离的项目中可以借助服务器实现跨域，具体做法是：前端向本地服务器发送请求，本地服务器代替前端再向真实服务器接口发送请求进行服务器间通信，本地服务器其实充当个「中转站」的角色，再将响应的数据返回给前端
缺点：服务器跨域需要另起服务器
4、postmessage跨域
在 HTML5 中新增了 postMessage 方法，postMessage 可以实现跨文档消息传输 Cross Document Messaging，IE8，Firefox 3，Opera 9，Chrome 3 和 Safari 4 都支持 postMessage。
该方法可以通过绑定 window 的 message 事件来监听发送跨文档消息传输内容。
使用 postMessage 实现跨域的话原理就类似于 jsonp，动态插入 iframe标签，再从 iframe 里面拿回数据
，私认为用作跨页面通信更加适合
总结
当然还有其他实现跨域的方式比如在ie8、9下 XDR 跨域方案，flash 方案，以上是一些常用的跨域方案，都各有利弊，比如：jsonp 只能发送 get 请求、服务器跨域需要另起服务器等等，大家可以根据自己项目需求选择适合的解决方案，
```

### 简述什么是REST?

```
REST，英文全称，Resource Representational State Transfer，对资源的访问状态的变化通过url的变化表述出来。
Resource：资源。资源是REST架构或者说整个网络处理的核心。
Representational：某种表现形式，比如用JSON，XML，JPEG等。
State Transfer：状态变化。通过HTTP method实现。
REST描述的是在网络中client和server的一种交互形式。用大白话来说，就是通过URL就知道要什么资源，通过HTTP method就知道要干什么，通过HTTP status code就知道结果如何。

举个例子：

GET /tasks 获取所有任务
POST /tasks 创建新任务
GET /tasks/{id} 通过任务id获取任务
PUT /tasks/{id} 更新任务
DELETE /tasks/{id} 删除任务
GET代表获取一个资源，POST代表添加一个资源，PUT代表修改一个资源，DELETE代表删除一个资源。

server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。用HTTP Status Code传递server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。
```

### 简述b、B、KB、MB、GB的关系 ？

```
b --->位(bit)
B --->字节 一个字节等于8位
1B = 8 bit
1kb = 1024 B
1 MB = 1024 KB
1 GB = 1024 MB
```

### 位和字节的关系 ？

```
1字节 = 8 位
位（bit），数据存储是以“字节”（Byte）为单位，数据传输是以大多是以“位”（bit，又名“比特”）为单位，
一个位就代表一个0或1（即一个二进制），二进制是构成存储器的最小单位，每8个位（bit，简写为b）组成一个字节（Byte，简写为B），
字节是最小一级的信息单位
```

### 简述字节码和机器码的区别 ？

```
什么是机器码

机器码(machine code)，学名机器语言指令，有时也被称为原生码（Native Code），是电脑的CPU可直接解读的数据。
通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。

总结：机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写

什么是字节码
字节码（Bytecode）是一种包含执行程序、由一序列 op 代码/数据对 组成的二进制文件。
字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。

总结：字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码
```

### 简述简述变量命名规范 ？

```
#1、以字母，数字，下划线任由结合
#2、不能以命名太长，不使用拼音，中文
#3、不能以数字开头
#4、不能用关键词
```

### 简述 进程、线程、协程的区别 以及应用场景？

```
线程是指进程内的一个执行单元，
# 进程
进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
# 线程
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度
# 协程和线程
协程避免了无意义的调度，由此可以提高性能；但同时协程也失去了线程使用多CPU的能力

进程与线程的区别
（1）地址空间：线程是进程内的一个执行单位，进程内至少有一个线程，他们共享进程的地址空间，而进程有自己独立的地址空间
（2）资源拥有：进程是资源分配和拥有的单位，同一个进程内线程共享进程的资源
（3）线程是处理器调度的基本单位，但进程不是
（4）二者均可并发执行
（5）每个独立的线程有一个程序运行的入口

协程与线程
（1）一个线程可以有多个协程，一个进程也可以单独拥有多个协程，这样Python中则能使用多核CPU
（2）线程进程都是同步机制，而协程是异步
（3）协程能保留上一次调用时的状态
```

### 如何修改本地hosts件？

```
Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，
当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，
一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。

浏览器访问网站，要首先通过DNS服务器把要访问的网站域名解析成一个唯一的IP地址，之后，浏览器才能对此网站进行定位并且访问其数据。

文件路径：C:\WINDOWS\system32\drivers\etc。
将127.0.0.1 www.163.com 添加在最下面
修改后用浏览器访问“www.163.com”会被解析到127.0.0.1，导致无法显示该网页。
```

### 生产者消费者模型应用场景及优势？

```
生产者与消费者模式是通过一个容器来解决生产者与消费者的强耦合关系，生产者与消费者之间不直接进行通讯，
而是利用阻塞队列来进行通讯，生产者生成数据后直接丢给阻塞队列，消费者需要数据则从阻塞队列获取，
实际应用中，生产者与消费者模式则主要解决生产者与消费者生产与消费的速率不一致的问题，达到平衡生产者与消费者的处理能力，而阻塞队列则相当于缓冲区。

应用场景：用户提交订单，订单进入引擎的阻塞队列中，由专门的线程从阻塞队列中获取数据并处理

优势：
1；解耦
假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。
将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。
2：支持并发
生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只能一直等着
而使用这个模型，生产者把制造出来的数据只需要放在缓冲区即可，不需要等待消费者来取

3：支持忙闲不均
缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。
当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。
```

### 简述什么是CDN ？

```
DN是什么？CDN其全称是Content Delivery Network，即内容分发网络。CDN是构建在网络上的内容分发网络，具备内容存储和分发两个关键要素。其基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。比如说，北京的用户让他访问北京的节点，上海的用户让它访问上海的节点，而不是北京的用户访问上海的节点，上海的用户访问北京的节点，这样会极大增加用户的访问时长，及访问的成本。通过就近访问，加速用户对网站的访问，解决Internet网络拥堵状况，提高用户访问网络的响应速度。CDN就像网络中的快递小哥，把你网购的商品从最近的仓库拿出并选择最优的路线，并将包裹及时地送到指定收货地点。CDN就是扮演护航及加速的角色，使得每一个网络请求能够请求更快，时延更小，响应更快，带来更为极致的用户体验
```

### MySQL 与Redis 的区别？

```
MySQL 与Redis 类型上：
mysql是关系型数据库，redis是缓存数据库（No-SQL数据库）

MySQL 与Redis 作用上：
mysql用于持久化的存储数据到硬盘，功能强大，速度较慢，基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高。
redis用于存储使用较为频繁的数据到缓存中，读取速度快，基于内存，读写速度快，也可做持久化，但是内存空间有限，当数据量超过内存空间时，需扩充内存，但内存价格贵。

MySQL 与Redis 需求上：
mysql和redis因为需求的不同，一般都是配合使用。
需要高性能的地方使用Redis，不需要高性能的地方使用MySQL。
存储数据在MySQL和Redis之间做同步。
```

### 解释什么是事务，知道事务提交、回滚？

```
事务是并发控制单位，用户定义的一个操作序列。这些操作要么都做，要么都不做，是不可分割的的工作单位。通过事务，sql server能将逻辑相关的一组操作绑定在一起，以便服务器保持数据的完整性，主要用于一些对操作过程的完整性比较高的程序。（事务的特性：原子性、一致性、隔离性、持久性）。

事务提交：是提交事务的所有操作：具体来说就是将所有对数据库的更新写回到磁盘上的物理数据库中，事务正常结束。

事务回滚：是数据库返回到事务开始的状态；事务在运行过程中发生某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的更新操作全部撤销，使数据回滚到事务开始时的状态。
```

### 什么是分布式系统架构？

```
1：互联网应用的特点是：高并发，海量数据。互联网应用的用户数是没有上限的(取决于其开放特性)，这也是和传统应用的本质区别。高并发指系统单位时间内收到的请求数量（取决于使用的用户数），没有上限。海量数据包括：海量数据的存储和海量数据的处理。这两个工程难题都可以使用分布式系统来解决。
简单理解，分布式系统就是把一些计算机通过网络连接起来，然后协同工作。协同工作需要解决两个问题：
1）任务分解
把一个问题拆解成若干个独立任务，每个任务在一台节点上运行，实现多任务的并发执行。
2）节点通信
节点之间互相通信，需要设计特定的通信协议来实现。协议可以采用RPC或Message Queue等方式。

2：分布式和集群的关系
分布式：一个业务分拆多个子业务，部署在不同的服务器上
集群：同一个业务，部署在多个服务器上
```

### 解释什么是脏数据？

```
一、脏数据是指什么数据
脏数据是指那些不符合预期、不合法或无效的数据，也叫“垃圾数据”、“坏数据”。脏数据可能出现在各种数据源中，包括文件、数据库、网络数据等。例如，一个数据库表中存储了身高信息，但其中有一个记录的身高被错误地输入为负数，这就是一个脏数据。
脏数据会影响数据的统计、分析和决策，甚至会导致程序崩溃或安全漏洞。因此，及时识别和清理脏数据对业务运营非常重要。

二、脏数据是指什么举例说明
脏数据具体体现为数据中的错误、缺失、重复、不一致等问题。

例如，一个电子商务网站的用户信息表中可能存在以下问题:
1. 错误数据：用户年龄为负数或超过了一百岁；
2. 缺失数据：用户姓名或手机号为空；
3. 重复数据：同一用户信息被记录多次；
4. 不一致数据：同一用户的不同信息记录中，性别、出生日期等信息不一致。

三、MySQL脏数据是指什么
在MySQL数据库中，脏数据指因为某些错误导致数据丢失、数据不一致、数据损坏或数据冲突的情况。常见的脏数据包括：
1. 丢失数据：从数据库中意外删除数据导致数据丢失；
2. 重复数据：同一记录被重复插入数据库中；
3. 不一致数据：多表关联查询中返回的结果不一致；
4. 数据损坏：文件系统故障、磁盘损坏、介质故障等原因导致数据库文件损坏。

-- 举例说明重复数据的查询
SELECT user_id, COUNT(*) FROM user GROUP BY user_id HAVING COUNT(*) > 1;
四、数据库中脏数据是指什么
数据库中的脏数据包括了几乎所有可能发生的数据质量问题。它们可以是因录入错误或非法字符等原因导致的无效数据、缺失数据、外键关联错误等等
因此，数据库管理员应该关注并定期检查数据的质量、完整性和一致性，并对脏数据进行清理和维护。

五、数据是指什么
数据是以某种形式记录的信息，可以是数字、文本、图像、音频等形式。数据可以帮助我们进行分析、预测、诊断和决策。数据质量对于数据分析和决策非常重要，而脏数据则会影响数据的质量，降低数据的分析和决策价值。

六、脏数据是什么
脏数据指那些不符合预期、不合法或无效的数据，与规范的数据定义相违背。这些不规范的数据可能会妨碍数据分析和业务决策的准确性和有效性。在业务系统中，脏数据的出现被认为是偶然事件，但是它们可能会对业务的正常运行造成异常情况。用户应该保证数据的准确性和完整性来防止脏数据被插入到系统中。

七、脏数据是指
脏数据是指那些不符合预期、不合法或无效的数据，也叫做垃圾数据、坏数据等。脏数据的出现会导致各种问题，影响决策和业务分析的有效性。对于不同类型的系统，脏数据的影响也是不同的。

八、什么是读脏数据
读脏数据是指在并发数据库读操作时，一个事务读到了另一个事务未提交的脏数据。读脏数据会导致数据不一致性和幻影读等问题。
解决读脏数据问题的常用方式是通过锁机制来控制并发读写操作，例如采用共享锁和排它锁。

-- 举例说明共享锁和排它锁的应用
-- 在事务1中获取共享锁
START TRANSACTION;
SELECT * FROM user WHERE age > 18 FOR SHARE;
-- 在事务2中获取排它锁
START TRANSACTION;
UPDATE user SET age = 30 WHERE id = 1 FOR UPDATE;
```

### 解释什么是幂等性？

```
幂等性就是用户对同一操作发起一次请求或者多次请求的结果是一致的。不会因为多次点击二次产生副作用。简单的例子，就是支付，用户购买商品使用支付，支付扣款成功，但是返回结果的时候网络异常，此事钱已经扣了，用户再次点击，此时会产生二次扣款，结果返回成功，用户查询余额返现多扣钱了。流水记录变成了两条、这就是幂等性。
```

### Python中列表和字典的区别，列表和元祖的区别 ？

```
元祖（tuple）：元祖常用小括号表示，即:()，元素加逗号，是元祖的标识。
列表（list）：列表常用方括号表示，即:[]，创建一个列表，只要把用逗号分隔的不同的数据项使用方括号括起来即可。
字典（dict）：字典是由花括号{}来包含其数据的，花括号内包含键(key)和其对应的值(value)，一对键和值成为一个项，键和值用冒号:隔开，项和项之间用逗号,隔开，空字典就是不包含任何项的字典，也可理解为空字典就是花括号内不包含任何内容，直接使用花括号{}表示列表和字典的区别：字典的查找和插入的速度极快，不会随着key值的增加而增加，需要占用大量的内存，内存浪费多
列表和元祖的区别：元祖比列表操作速度快，对数据不可更改、可用于字符串格式化中、可作为字典的key
```

### 解释什么是多线程？

```
线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。
多线程是这样一种机制，它允许在程序中并发执行多个指令流，每个指令流都称为一个线程，彼此间互相独立。线程又称为轻量级进程，它和进程一样拥有独立的执行控制，由操作系统负责调度。
多线程是多任务的特殊形式。通常，有两种类型的多任务：基于进程和基于线程的多任务。进程本质上是正在执行的程序。
因此，基于进程的多任务就是允许您的计算机同时运行两个或者更多程序的特性。例如，基于进程的多任务允许您在使用电子制表软件或者浏览Internet的同时运行文字处理程序。在基于进程的多任务中，程序是调度程序可以分派的最小代码单元。
多线程是为了使得多个线程并行的工作以完成多项任务，以提高系统的效率。线程是在同一时间需要完成多项任务的时候被实现的
```

### 进程、线程、协程的区别 ？

```
1、一个程序至少有一个进程，一个进程至少有一个线程
2、线程的划分尺度小于进程（资源比进程少），使得多线程程序并发性高
3、进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大提高了程序的运行效率
4、线程不能独立运行，必须依存于进程中
5、一个线程可以多个协程，一个进程也可以单独拥有多个协程
6、线程进程都是同步机制，协程是异步机制
```

### HTTP常见的状态码？

```
200 ok ：表示访问成功，请求正常处理完毕
404 Not Found ：表示没有找到资源，一般页面提示：请求的资源无法找到等类似提示
403 Forbidden : 表示访问被拒绝
500 Interal Server Error: 表示服务器内部出现错误，无法完成请求
504 Gateway Timeout: 表示请求超时
```

### 解释什么是版本控制？常见的版本控制系统有哪些？

```
最常见的版本控制系统有：Git和SVN
Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git有很多图形界面工具，推荐SourceTree，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。
SVN 是 Subversion 的简称，是一个开放源代码的版本控制系统，相较于 RCS、CVS，它采用了分支管理系统。TortoiseSVN是一款非常易于使用的Windows版本控制/版本控制/源代码控制软件。它基于Apache™ 颠覆（SVN）®；TortoiseSVN为Subversion提供了一个漂亮而简单的用户界面。我们需要在本地安装客户端：TortoiseSVN，安装成功之后输入用户名和密码进行登录，即可查看到SVN上的文件内容
```

### Cookie的介绍？

```
cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie 是纯文本格式，不包含任何可执行的代码。一个 Web 页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web 服务器就可以使用这些信息来识别不同的用户。大多数需要登录的网站在用户验证成功之后都会设置一个 cookie，只要这个 cookie 存在并可以，用户就可以自由浏览这个网站的任意页面。再次说明，cookie 只包含数据，就其本身而言并不有害。
Cookie 可以解决http无状态的问题，与服务器进行交互，作为http规范存在。它具有极高的简便性、可扩展性、和可用性、也可以通过加密和ssl技术来提高其安全性。因此推荐使用cookie作为标识而不是身份验证的工具。其中cookie的作用就是为了解决HTTP协议无状态的缺陷所作出的努力。
```

### http与https区别（加密传输）？

```
http协议和https协议的区别：传输信息安全性不同、连接方式不同、端口不同、证书zhuan申请方式不同、传输信息安全性不同
1、http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息；
2、https协议：是具有安全性的ssl加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全。
二、连接方式不同
1、http协议：http的连接很简单，是无状态的；
2、https协议：是由SSL＋HTTP协议构建的可进行加密传输、身份认证的网络协议。
三、端口不同
http协议：使用的端口是80； https协议：使用的端口是443。
四、证书申请方式不同
http协议：免费申请 https协议：需要到ca申请证书，一般免费证书很少，需要交费
```

### 快速区分bug来源以及常见状态码？

```
状态码 原因短语
1XX Informational （信息性状态码） 接收的请求正在处理
2XX Success （成功状态码） 请求正常处理完毕
3XX Redirection （重定向状态码) 需要进行附加操作以完成请求
4XX Client Error（客户端错误状态码） 服务器无法处理请求
5XX Server Error （服务器错误状态码) 服务器处理请求出错
```

### 解释什么是负载测试？

```
负载测试主要是考察软件系统在既定负载下的性能表现。就是站在用户的角度去观察一定条件下软件系统的性能表现。期望结果是用户的性能指标需求得到满足。性能指标一般体现为响应时间、并发量等。
```

### 常用的Linux命令？

```
shutdown -h now 立刻关机
shutdown -h 5 5分钟后关
poweroff 立刻关机
shutdown -r now 立刻重启
shutdown -r 5 5分钟后重启
reboot 立刻重启
cd / 切换到根目录cd
/usr 切换到根目录下的usr目录
cd …/ 切换到上一级目录 或 cd … cd ~ 切换到home目录
cd - 切换到上次访问的目录
ls 查看当前目录下的所有目录和文件
ls -a查看当前目录下的所有目录和文件（包括隐藏的文件）
ls -l 列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）
ls / 查看指定目录下的所有目录和文件
查找命令
grep 命令是一种强大的文本搜索工具
find 命令在目录结构中搜索文件，并对搜索结果执行指定的作。
locate 让使用者可以很快速的搜寻某个路径。
whereis 命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。
which 命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。
命令格式
crontab [-u user] file
crontab [-u user] [ -e | -l | -r ]
参数说明：
-u user：用来设定某个用户的crontab服务
file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。
-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。
-l：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前用户的crontab文件内容。
-r：删除定时任务配置，从/var/spool/cron目录中删除某个用的crontab
文件，如果不指定用户，则默认删除当前用户的crontab文件。
命令：pwd 查看当前目录路径
命令：ps -ef 查看所有正在运行的进程
命令：kill pid 或者 kill -9 pid(强制杀死进程) pid:进程号
ifconfig：查看网卡信息
命令：ifconfig 或 ifconfig | more
ping：查看与某台机器的连接情况
命令：ping ip
netstat -an：查看当前系统端口
命令：netstat -an
搜索指定端口
命令：netstat -an | grep 8080
```

### Linux目录操作？

```
【增】 mkdir
mkdir aaa 在当前目录下创建一个名为aaa的目录
mkdir /usr/aaa 在指定目录下创建一个名为aaa的目录
【删】rm
删除文件：
rm 文件 删除当前目录下的文件
rm -f 文件 删除当前目录的的文件（不询问）
删除目录：
rm -r aaa 递归删除当前目录下的aaa目录
rm -rf aaa 递归删除当前目录下的aaa目录（不询问）
全部删除：
rm -rf * 将当前目录下的所有目录和文件全部删除
rm -rf /* 【慎用！慎用！慎用！】将根目录下的所有文件全部删除
注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包
【改】mv 和 cp
重命名目录
命令：mv 当前目录 新目录
例如：mv aaa bbb 将目录aaa改为bbb
剪切目录
命令：mv 目录名称 目录的新位置（将/usr/tmp目录下的aaa目录剪切到/usr目录下面 mv/usr/tmp/aaa/usr）
拷贝目录
命令：cp -r 目录名称 目录拷贝的目标位置 -r代表递归
（将/usr/tmp目录下的aaa目录复制到 /usr目录下面 cp /usr/tmp/aaa /usr）
【查】find
命令：find 目录 参数 文件名称
示例：find /usr/tmp -name ‘a*’ 查找/usr/tmp目录下的所有以a开头的目录或文件
```

### 常用的MySQL命令？

```
【增】insert
insert into 表名 values(值1，值2，…)；
insert into 表名(字段1，字段2…) values(值1，值2，…);（较常用）
insert into 表名(字段1，字段2…) values(值1，值2，…)，(值1，值2，…)，(值1，值2，…);

【删】delete
delete from 表名 where 条件

【改（更新）】update
update 表名 set字段1 = 值1, 字段2 = 值2 where 条件

重要*【查】select
select * from 表名 查询表中的所有数据
select 字段 from 表名 指定数据查询
select 字段 from 表名 where 条件 根据条件查询出来的数据

where 条件后面跟的条件
关系：>,<,>=,<=,!=
逻辑：or, and
区间：id between 4 and 6 ;闭区间，包含边界

【排序】
select 字段 from 表 order by 字段 排序关键词(desc | asc)
排序关键词 desc 降序 asc 升序(默认)
通过字段来排序 ：select * from star orser by money desc, age asc;
多字段排序 ：select 字段 from 表 order by 字段1 desc |asc,…字段n desc| asc;

【常用的统计函数】 sum，avg，count，max,min
```

### MySQL多表联合查询 ？

```
1.内连接
隐式内连接 select username,name from user,goods where user,gid=gods,gid;
显示内连接 select username,from user inner join goods on user.gid=goods.gid;
select * from user left join goods on user.gid=goods.gid;
2.外链接 左/右连接
select * from user where gid in(select gid from goods);
select * from user right jOin goods on user.gid=goods.gid；
3.数据联合查询
select * from user left join goods on user.gid=goods.gid union select * from user right join goods on user.gid=goods.gid;
4.两个表同时更新
update user u, goods g set u.gid=12,g.price=1 where u.id=2 and u.gid=g.gid;
```

### 描述软件产生内存泄露的原因以及检查方式？

```
内存泄露的原因，主要是由于开发过程当中申请了计算机资源（例如对象、内存等），但是使用资源完成以后没有及时释放资源导致的。例如在C语言当中使用了malloc申请了内存，但是未使用free来释放内存。
```

### 简述什么是值传递，什么是地址传递，两者区别是什么？

```
值传递主调函数传递给被调函数的是值的拷贝，不是原值；地址传递主调函数传递给被调函数的是值的地址。区别是值传递被调函数中的操作不改变主调函数的值，而地址传递则不同。
```

### 结构化程序设计和面向对象程序设计各自的特点及优缺点是什么？

```
结构化程序设计思想采用了模块分解与功能抽象和自顶向下、分而治之的方法，从而有效地将一个较复杂的程序系统设计任务分解成许多易于控制和处理的子程序，便于开发和维护。它的重点在于把功能进行分解。但是由于在实际开发过程当中需求会经常发生变化，因此，它不能很好的适应需求变化的开发过程。结构化程序设计是面向过程的。

面向对象程序设计以需求当中的数据作为中心，来进行设计，具有良好的代码重用性。
封装性：也叫数据隐藏，用户无需知道内部工作流程，只要知道接口和操作就可以的，C++中一般用类来实现封装。

继承性： 一种支持重用的思想，在现有的类型派生出新的子类，例如新型电视机在原有型号的电视机上增加若干中功能而得到，新型电视机是原有电视机的派生，继承了原有电视机的属性，并增加了新的功能。

多态性：指在一般类中定义的属性或行为，被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。
动态联编：指一个计算机程序自身彼此关联的过程，按照联编所进行的阶段不同，可分为两种不同的联编方法：静态联编和动态联编。
```

### 简述什么是存储过程和触发器？

```
存储过程：是数据库中的一个对象，Transact-SQL 语句的预编译集合，这些语句在一个名称下存储并作为一个单元进行处理。（可以理解为C语言中的函数，有参数、返回值等函数特性）
触发器是一种特殊类型的存储过程，当使用下面的一种或多种数据修改操作在指定表中对数据进行修改时，触发器会生效：UPDATE、INSERT 或 DELETE。
```

### 说出4种以上常用的操作系统及其主要的应用范围（微软的操作系统除外）？

```
Linux（Red Hat、SUSE、Debian、Trubo Linux）：主要用于搭建各类服务器
MAC OS：苹果机的操作系统，用于图像处理
Unix（AIX：IBM服务器的专用操作系统；
Solaris：Sun操作系统；FreeBSD、NetBSD）
```

### Windows操作系统中PATH环境变量的作用是什么？

```
PATH是Windows操作系统环境变量，PATH作用是用户在命令行窗口执行一个命令，则在PATH变量设置的目录下依次寻找该命令或对应的执行文件，若找到，则执行，若没有找到，则命令行窗口返回无效命令。
```

### Ghost的主要用途和常用方法？

```
Ghost是一个非常著名的硬盘克隆工具。该工具的主要作用是可以将一个硬盘或硬盘中的某个分区原封不动的复制到另一个硬盘或其他的分区中。如果你需要备份启动分区或者是需要在多台机器上安装相应的系统和应用程序，都可以通过Ghost来实现，相信通过这个工具备份，恢复速度和硬盘安装速度会成倍的提高。
Norton Ghost有一个很大的特点，就是在克隆硬盘时不会改变任何文件信息，程序可以很好的支持FAT16、FAT32以及NTFS格式的文件分配结构（其中包括Windows 2000的文件分配格式），虽然是DOS环境下运行的程序，但工具可支持Win 9x的长文件名特性。
常用方法包括：硬盘克隆、分区克隆、硬盘或分区克隆成镜像文件等。
```

### 对RUP.CMM,CMMI,XP,PSP.TSP的认识？

```
软件过程标准：CMMI、PSP、TSP、RUP、软件工程规范国家标准；（AP、XP、ASD等开发过程思想好像还不能称其为标准）
RUP（Rational Unified Process）是Rational公司提出的一套开发过程模型，它是一个面向对象软件工程的通用业务流程。它描述了一系列相关的软件工程流程，它们具有相同的结构，即相同的流程构架。RUP 为在开发组织中分配任务和职责提供了一种规范方法，其目标是确保在可预计的时间安排和预算内开发出满足最终用户需求的高品质的软件。RUP具有两个轴，一个轴是时间轴，这是动态的。另一个轴是工作流轴，这是静态的。在时间轴上，RUP划分了四个阶段：初始阶段、细化阶段、构造阶段和发布阶段。每个阶段都使用了迭代的概念。在工作流轴上，RUP设计了六个核心工作流程和三个核心支撑工作流程，核心工作流轴包括：业务建模工作流、需求工作流、分析设计工作流、实现工作流、测试工作流和发布工作流。核心支撑工作流包括：环境工作流、项目管理工作流和配置与变更管理工作流。RUP 汇集现代软件开发中多方面的最佳经验，并为适应各种项目及组织的需要提供了灵活的形式。作为一个商业模型，它具有非常详细的过程指导和模板。但是同样由于该模型比较复杂，因此在模型的掌握上需要花费比较大的成本。尤其对项目管理者提出了比较高的要求。
CMM(Capability Maturity Model能力成熟度模型) 由美国卡内基-梅隆大学的软件工程研究所（简称SEI）受美国国防部委托，于1991年研究制定，初始的主要目的是为了评价美国国防部的软件合同承包组织的能力，后因为在软件企业应用CMM模型实施过程改进取得较大的成功，所以在全世界范围内被广泛使用，SEI同时建立了主任评估师评估制度，CMM的评估方法为CBA－IPI。CMM的本质是软件管理工程的一个部分。它是对于软件组织在定义，实现，度量，控制和改善其软件过程的进程中各个发展阶段的描述。他通过5个不断进化的层次来评定软件生产的历史与现状：初始层是混沌的过程；可重复层是经过训练的软件过程；定义层是标准一致的软件过程；管理层是可预测的软件过程；优化层是能持续改善的软件过程。
CMM/PSP/TSP即软件能力成熟度模型/ 个体软件过程/群组软件过程，是1987年美国 Carnegie Mellon 大学软件工程研究所(CMU/SEI)以W.S.Humphrey为首的研究组发表的研究成果"承制方软件工程能力的评估方法"。
CMMI是SEI于2000年发布的CMM的新版本。CMMI不但包括了软件开发过程改进，还包含系统集成、软硬件采购等方面的过程改进内容。
CMMI纠正了CMM存在的一些缺点，使其更加适用企业的过程改进实施。CMMI适用SCAMPI评估方法。需要注意的是，SEI没有废除CMM模型，只是停止了CMM评估方法：CBA－IPI。现在如要进行CMM评估，需使用SCAMPI方法。但CMMI模型最终代替CMM模型的趋势不可避免。
XP （极限编程）规定了一组核心价值和方法，可以让软件开发人员发挥他们的专长：编写代码。XP 消除了大多数重量型过程的不必要产物，通过减慢开发速度、耗费开发人员的精力（例如干特图、状态报告，以及多卷需求文档）从目标偏离。
```

### 简述c/s模式或者b/s模式？

```
C/S模式：客户端/服务器模式。工作原理：Client向Server提交一个请求；Server则使用一些方法处理这个请求，并将效果返回给Client。
B/S结构，即Browser/Server(浏览器/服务器)结构，是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现，形成所谓3-tier结构。B/S结构，主要是利用了不断成熟的WWW浏览器技术，结合浏览器的多种Script语言(VBScript、JavaScript…)和ActiveX技术，用通用浏览器就实现了原来需要复杂专用软件才能实现的强大功能，并节约了开发成本，是一种全新的软件系统构造技术
```

### PUT和POST方法有什么区别？

```
POST用于在服务器上创建新对象，PUT请求用于在替换对象。当客户端将页面发送到服务器，然后服务器让客户端知道它放在何处时，应该使用POST。当客户端指定页面的位置时，应使用PUT。
```

### SOAP 和 REST 有什么区别？

```
SOAP 是一种协议，两台计算机可以通过共享 XML 文档进行通信。
SOAP 仅允许 XML
基于 SOAP 的读取不能被缓存
SOAP 就像 定制桌面应用程序，它紧密连接到服务器
SOAP 比 REST 慢
它在 HTTP 上运行，但封装了消息

Rest 是基于网络的软件体系结构的服务体系结构和设计
REST 支持许多不同的数据格式
REST 读取可被缓存
A REST 客户更像是一个浏览器； 它知道如何标准化方法，并且应用程序必须适合其中
REST 比 SOAP
更快，它使用 HTTP 标头保存元信息
```

### 常用设计模式有哪些？

```
设计模式根据工作的目的，分为创建型模式、结构型模式和行为型模式三类。
创建型模式：单例模式、工厂方法模式、抽象工厂模式、创建者模式、原型模式。
结构型模式：适配器模式、代理模式、装饰器模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

软件设计七大原则(OOP原则)
开闭原则：对扩展开放，对修改关闭。
里氏替换原则：不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义。
依赖倒置原则：要面向接口编程，不要面向实现编程。
单一职责原则：控制类的粒度大小、将对象解耦、提高其内聚性。
接口隔离原则：要为各个类建立它们需要的专用接口。
迪米特法则：一个类应该保持对其它对象最少的了解，降低耦合度。
合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。
实际上，七大原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。
```

### 分布式和集群的概念？

```
分布式：是指将不同的业务分布在不同的地方，
集群：是指将几台服务器集中在一起，实现同一业务。

分布式中的每一个节点，都可以做集群，而集群并不一定就是分布式的。集群有组织性，一台服务器垮了，其它的服务器可以顶上来，而分布式的每一个节点，都完成不同的业务，一个节点垮了，哪这个业务就不可访问了。
```

### OSI七层模型？

```
【物理层】
在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。
物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。
物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

【数据链路层】
数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。
在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。
该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。
MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；
LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。
数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。

【网络层】
网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。
一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。
在实现网络层功能时，需要解决的主要问题如下：
寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。
交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。
路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。

连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。

【传输层】
OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。

该层的主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。
传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：
传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。
处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。

监控服务质量。

【会话层】
会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。
用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名（DN）就是一种网络上使用的远程地址例如：www.3721.com就是一个域名。会话层的具体功能如下：
会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。
会话流量控制：提供会话流量控制和交叉会话功能。
寻址：使用远程地址建立会话连接。l
出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。

【表示层】
表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。表示层的具体功能如下：
数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。
数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。
压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。
数据的加密和解密：可以提高网络的安全性。

【应用层】
应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。
应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。应用层的主要功能如下：
用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。
实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。
```

### SSL层原理？

```
SSL利用数据加密、身份验证和消息完整性验证机制，为网络上数据的传输提供安全性保证。SSL支持各种应用层协议。由于SSL位于应用层和传输层之间，所以可以为任何基于TCP等可靠连接的应用层协议提供安全性保证。

1.身份验证机制
SSL利用数字签名来验证通信对端的身份。非对称密钥算法可以用来实现数字签名。由于通过私钥加密后的数据只能利用对应的公钥进行解密，因此根据解密是否成功，就可以判断发送者的身份，如同发送者对数据进行了“签名”。例如，Alice使用自己的私钥对一段固定的信息加密后发给Bob，Bob利用Alice的公钥解密，如果解密结果与固定信息相同，那么就能够确认信息的发送者为Alice，这个过程就称为数字签名。使用数字签名验证身份时，需要确保被验证者的公钥是真实的，否则，非法用户可能会冒充被验证者与验证者通信。如下图所示，Cindy冒充Bob，将自己的公钥发给Alice，并利用自己的私钥计算出签名发送给Alice，Alice利用“Bob”的公钥（实际上为Cindy的公钥）成功验证该签名，则Alice认为Bob的身份验证成功，而实际上与Alice通信的是冒充Bob的Cindy。SSL利用PKI提供的机制保证公钥的真实性。

2.数据传输的机密性
SSL加密通道上的数据加解密使用对称密钥算法，目前主要支持的算法有DES、3DES、AES等，这些算法都可以有效地防止交互数据被破解。对称密钥算法要求解密密钥和加密密钥完全一致。因此，利用对称密钥算法加密传输数据之前，需要在通信两端部署相同的密钥。

3. 消息完整性验证
为了避免网络中传输的数据被非法篡改，SSL利用基于MD5或SHA的MAC算法来保证消息的完整性。MAC算法是在密钥参与下的数据摘要算法，能将密钥和任意长度的数据转换为固定长度的数据。利用MAC算法验证消息完整性的过程如下图所示。发送者在密钥的参与下，利用MAC算法计算出消息的MAC值，并将其加在消息之后发送给接收者。接收者利用同样的密钥和MAC算法计算出消息的MAC值，并与接收到的MAC值比较。如果二者相同，则报文没有改变；否则，报文在传输过程中被修改，接收者将丢弃该报文。

MAC算法要求通信双方具有相同的密钥，否则MAC值验证将会失败。因此，利用MAC算法验证消息完整性之前，需要在通信两端部署相同的密钥。

4.利用非对称密钥算法保证密钥本身的安全
对称密钥算法和MAC算法要求通信双方具有相同的密钥，否则解密或MAC值验证将失败。因此，要建立加密通道或验证消息完整性，必须先在通信双方部署一致的密钥。SSL利用非对称密钥算法加密密钥的方法实现密钥交换，保证第三方无法获取该密钥。如下图所示，SSL客户端（如Web浏览器）利用SSL服务器（如Web服务器）的公钥加密密钥，将加密后的密钥发送给SSL服务器，只有拥有对应私钥的SSL服务器才能从密文中获取原始的密钥。SSL通常采用RSA算法加密传输密钥。（Server端公钥加密密钥，私钥解密密钥）

实际上，SSL客户端发送给SSL服务器的密钥不能直接用来加密数据或计算MAC值，该密钥是用来计算对称密钥和MAC密钥的信息，称为premaster secret。SSL客户端和SSL服务器利用premaster secret计算出相同的主密钥（master secret），再利用master secret生成用于对称密钥算法、MAC算法等的密钥。premaster secret是计算对称密钥、MAC算法密钥的关键。

5.利用PKI保证公钥的真实性
PKI通过数字证书来发布用户的公钥，并提供了验证公钥真实性的机制。数字证书（简称证书）是一个包含用户的公钥及其身份信息的文件，证明了用户与公钥的关联。数字证书由权威机构——CA签发，并由CA保证数字证书的真实性。

SSL客户端把密钥加密传递给SSL服务器之前，SSL服务器需要将从CA获取的证书发送给SSL客户端，SSL客户端通过PKI判断该证书的真实性。如果该证书确实属于SSL服务器，则利用该证书中的公钥加密密钥，发送给SSL服务器。
验证SSL服务器/SSL客户端的身份之前，SSL服务器/SSL客户端需要将从CA获取的证书发送给对端，对端通过PKI判断该证书的真实性。如果该证书确实属于SSL服务器/SSL客户端，则对端利用该证书中的公钥验证SSL服务器/SSL客户端的身份。
```

### HTTP常见头格式 ？

```
1、Accept：text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, image/apng, */*; q=0.8
作用：向服务器申明客户端（浏览器）可以接受的媒体类型（MIME）的资源
解释：浏览器可以接受text/html、application/xhtml+xml、application/xml类型，通配符*/* 表示任意类型的数据。并且浏览器按照该顺序进行接收。( text/html —> application/xhtml+xml —> application/xml)
2、Accept-encoding: gzip, deflate, br
作用：向服务器申明客户端（浏览器）接收的编码方法，通常为压缩方法
解释：浏览器支持采用经过gzip，deflate 或 br 压缩过的资源

3、Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7
作用：向服务器申明客户端（浏览器）接收的语言
解释：浏览器能够接受en-US, en 和 zh-CN 三种语言，其中 en-US 的权重最高 ( q 最高为1，最低为 0)，服务器优先返回 en-US 语言
延伸：语言与字符集的区别：zh-CN 为汉语，汉语中有许多的编码：gbk2312 等

4、Cache-control: max-age=0
作用：控制浏览器的缓存，常见值为private、no-cache、max-age、alidate，默认为 private，根据浏览器查看页面不同的方式来进行区别
解释：浏览器在访问了该页面后，不再会访问服务器

5、Cookie:
作用：告诉服务器关于Session 的信息，存储让服务器辨识用户身份的信息。
6、Refer：https://www.baidu.com/xxxxxxxxxx
作用：告诉服务器该页面从哪个页面链接的
解释：该页面从https://www.baidu.com 中的搜索结果中点击过来的
7、Upgrade-insecure-requests：1
作用：申明浏览器支持从http 请求自动升级为 https 请求，并且在以后发送请求的时候都使用 https
解释：当页面中包含大量的http 资源的时候（图片、iframe），如果服务器发现一旦存在上述的响应头的时候，会在加载 http 资源的时候自动替换为 https 请求
8、User-agent：Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36
作用：向服务器发送浏览器的版本、系统、应用程序的信息。
解释：Chrome 浏览器的版本信息为 63.0.3239.132，并将自己伪装成 Safari，使用的是 WebKit 引擎，WebKit伪装成 KHTML，KHTML伪装成Gecko（伪装是为了接收那些为Mozilla、safari、gecko编写的界面）
延伸：可以随便填（但不应该随便填）不过一般用于统计。

9、X-Chrome-UMA-Enabled、X-Client-Data ：与 Chrome 浏览器相关的数据Response Headers
```

### TCP/IP四层网络协议？

```
TCP/IP四层网络协议分别是应用层，网络层，传输层，数据链路层
```

### Session概念和理解 ？

```
Session：在web开发中，服务器可以为每个用户创建一个会话对象(session对象)，默认情况下一个浏览器独占一个session对象，因此在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其他程序时，其他程序可以从用户的session中取出该用户的数据，为用户服务，其实现原理是服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session服务。
Session和cookie的区别：
1、cookie是把用户的数据写给用户浏览器
2、session是把用户的数据写到用户独占的session中
3、session对象由服务器创建，开发人员可以调用request对象的getsession方法得到session对象
```

### 跨域的原理和实现方案 ？

```
浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域
跨域的几种方案：
1:基于script标签实现跨域
3: 基于jquery跨域
4: 通过iframe来跨子域
```

### Redis的理解和实践？

```
Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
```

### 基本的基本的SQL语句汇总 ？

```
选择：select * from table1 where 范围
插入：insert into table1(field1,field2) values(value1,value2)
删除：delete from table1 where 范围
更新：update table1 set field1=value1 where 范围
查找：select * from table1 where field1 like '%value1%' ---like的语法很精妙，查资料!
排序：select * from table1 order by field1,field2 [desc]
总数：select count as totalcount from table1
求和：select sum(field1) as sumvalue from table1
平均：select avg(field1) as avgvalue from table1
最大：select max(field1) as maxvalue from table1
最小：select min(field1) as minvalue from table1
```

### 数据库中的聚类查询？

```
聚集索引中键值的逻辑顺序决定了表中相应行的物理顺序。聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节省成本。当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id 列上创建聚集索引或 PRIMARY KEY 约束。
如果不创建索引，系统会自动创建一个隐含列作为表的聚集索引。

1.创建表的时候指定主键（注意：SQL Sever默认主键为聚集索引，也可以指定为非聚集索引，而MySQL里主键就是聚集索引）
create table t1(
id int primary key,
name nvarchar(255)
)
2.创建表后添加聚集索引
SQL Server：
create clustered index clustered_index on table_name(colum_name)
MySQL：
alter table table_name add primary key(colum_name)
```

### 数据库事务、主键与外键的区别？

```
数据库的事务：事务即用户定义的一个数据库操作序列，这些操作要么全做要全不做，是一个不可分割的工作单位，它具有四个特性，ACID，原子性，一致性，隔离性，持续性
主键和外键的区别：
1.主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。
身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。
2.外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。
```

### 数据库count和sum的区别，以及count(*)和count(列名)的区别？

```
Count和sum区别:求和用累加sum()，求行的个数用累计count
Count（*）包括了所有的列，在统计结果的时候不会忽略列值为null
Count（列名）只包括列名那一项，会忽略列值为空的计数
```

### 进程和线程的区别？

```
进程：是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序。
线程：是进程的一个实体，是CPU调度和分派的基本单位，比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，在运行时，只是暂用一些计数器、寄存器和栈 。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间。
一个程序至少有一个进程,一个进程至少有一个线程。
```

### 虚拟内存的概念 ？

```
虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换
```

### 多进程、多线程，操作系统层面的差别和联系？

```
进程：进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序、数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。
线程：在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。

差别：1.线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；2.一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；3.进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；4.调度和切换：线程上下文切换比进程上下文切换要快得多。

联系：原则上一个CPU只能分配给一个进程，以便运行这个进程。通常使用的计算机中只有一个CPU，同时运行多个进程，就必须使用并发技术。通常采用时间片轮转进程调度算法，在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。但实际上在任何一个时间内有且仅有一个进程占有CPU。如果一台计算机有多个CPU，情况就不同了，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，多个进程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。在Windows中，进行CPU分配是以线程为单位的，一个进程可能由多个线程组成。操作系统将CPU的时间片分配给多个线程,每个线程在操作系统指定的时间片内完成(注意,这里的多个线程是分属于不同进程的).操作系统不断的从一个线程的执行切换到另一个线程的执行,如此往复,宏观上看来,就好像是多个线程在一起执行.由于这多个线程分属于不同的进程,就好像是多个进程在同时执行,这样就实现了多任务。总线程数<=CPU数量时并行运行，总线程数>CPU数量时并发运行。并行运行的效率显然高于并发运行，所以在多CPU的计算机中，多任务的效率比较高。但是，如果在多CPU计算机中只运行一个进程(线程)，就不能发挥多CPU的优势。
```

### 简述什么是数据库幻读？

```
幻读就是指当一个事务正在访问数据，并且对数据进行了修改，但是还没有来得及提交到数据库中，这时，另一个事务也访问这个数据，然后使用了这个数据
```

### URL的概念与组成？

```
URL由三部分组成：
资源类型、存放资源的主机域名、资源文件名
也可认为由4部分组成：
协议、主机、端口、路径。（很多时候端口都是隐藏的）
还可以认为由7部分组成：
协议，域名，端口，虚拟目录，文件名，锚，参数
URL的一般语法格式：
(带方括号[]的为可选项)
protocol :// hostname[:port] / path / [;parameters][?query]#fragment
```

### 阐述有哪些常见加密算法？

```
摘要算法（MD5.SHA1 ）：造接口数据前调用MD5，SHA1进行编码，服务端对比编码后的字符串是否一致。
对称加密算法（AES,DES ）：造接口数据前从开发获取对称公钥，基于对称公钥可以加密请求数据，解密响应报文。
非对称加密算法（RSA）：造接口数据前从开发获取公钥私钥去加密解密接口数据
```

### 简述什么是数据驱动？

```
数据驱动就是通过excel，或者xml，数据库等数据结构来维护测试数据，通过相应的技术去处理，拿到测试数据用于测试，从而实现测试数据与代码的解耦，数据驱动测试的本质是高级的参数化。
将测试用例放在excel中，使用数据驱动（如ddt）遍历每一条用例， 然后传递给被装饰的方法的一个参数,有几条数据 就执行几次用例。
```

### 简述什么是Token？

```
所谓token其实就是服务器端返回的一个字符串（有点类似于：xys73494954sdhcdr83435这么一串），这个数据是基于什么算法生成的需要找开发确认，一般这个数据是唯一的，服务器每次返回的token都会不一样。Token之所以可以用来做鉴权，原理如下：用户a调用了登录接口–》登录了系统b–》服务器端生成了一个唯一的token信息（假设为c），然后会拿用户的编号id（假设为d）做了一个映射：c-d，然后将这样的映射关系存到数据库或redis等缓存中，然后再返回这个token给客户端–》客户端再调用其他需要鉴权的接口时，只需要将缓存起来的这个token带过去验证–》服务器根据此token检查是否有登录用户信息来判断此请求是否是一个已登录授权的用户。
```

### 关系型数据库和非关系型数据库的区别？

```
关系型数据库最典型的数据结构是表。由二维表及其之间的数据联系所组成的数据组织。
优点：
1.易于维护：格式一致，都是使用表结构。
2.使用方便：SQL语言通用。
3.能完成一些复杂操作：支持SQL,可用于一个表及多个表之间非常复杂的查询。

缺点：
1.读写性能较差。
2.固定的表结构，灵活性欠缺。
3.高并发读写需求，是很大的瓶颈。

非关系型数据库严格意义上不是一种数据库，应该是一种数据格式化储存的集合，可以是文档或者键值对形式。
优点：
1.格式灵活
2.速度快：可以使用硬盘或者随机储存器作为载体，而关系型数据库只能使用硬盘。
3.高拓展性。
4.成本低，部署简单。

缺点：
1.不提供SQL支持，学习和使用的成本比较高。
2.无事务处理。
3.数据结构相对复杂，复杂查询方面稍微欠缺。
```

### 数据库中order by和group by的区别？

```
order by为排序查询、
ASC升序 DESC降序
group by为分组查询、
having只能用于group by子句、作用于组内、
having条件子句的查询语句需要使用聚合函数
```

### 关系数据库中主键和外键的区别？

```
主键在本表中是唯一的，不可为空的，外键可以重复可以为空。
外键和另一张表的主键关联，不能创建对应表中不存在的外键。
```

### 关系数据库中truncate和delete的区别？

```
相同处：二者均删除表中的全部行
不同处：
① truncate table比delete速度快
② delete语句每次删除一行，并在事务日志中为所删除的每行记录一项；truncate通过释放存储数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。
③ truncate table删除内容，释放空间但不删除定义
④ delete table删除内容，不删除定义但不释放空间
⑤ drop table删除内容和定义，释放空间
```

### 数据库中存储过程与函数的区别？

```
① 函数有返回值，存储过程没有返回值
② 因为存储过程没有返回值，所以不能将存储过程的执行结果赋值给变量；函数有返回值类型，调用函数时，可以将函数的执行结果赋值给变量。
```

### 什么是数据库约束，常见的约束有哪几种？

```
约束可以分为：
主键约束primary key、
外键约束foreign key、
唯一约束unique、
检查约束check、
空值约束not null、
默认值约束default
```
